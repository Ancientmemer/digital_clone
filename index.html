<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Bone Architect â€“ VR Optimized</title>
<style>
  body{margin:0;overflow:hidden;background:#000}
  video{
    position:fixed; inset:0;
    width:100vw;height:100vh;
    object-fit:cover;
    transform:scaleX(-1);
    z-index:-1;
  }
  canvas{position:fixed; inset:0}
</style>
</head>

<body>
<video id="video" autoplay playsinline></video>
<canvas id="three"></canvas>

<!-- MediaPipe -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<!-- Three.js -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>

<script>
/* ===================== BASIC SETUP ===================== */
const video = document.getElementById("video");
const canvas = document.getElementById("three");

/* ===================== THREE SCENE ===================== */
const scene = new THREE.Scene();
const camera3D = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 100);
camera3D.position.set(0,1.6,4);

const renderer = new THREE.WebGLRenderer({canvas, alpha:true});
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
renderer.setClearDepth(1);

/* video as background (optimized) */
const videoTex = new THREE.VideoTexture(video);
videoTex.minFilter = THREE.NearestFilter;
videoTex.magFilter = THREE.NearestFilter;
videoTex.generateMipmaps = false;
scene.background = videoTex;

/* ===================== MATERIAL ===================== */
const mat = new THREE.LineBasicMaterial({color:0x00f0ff});

/* ===================== HELPERS ===================== */
const vec = p => new THREE.Vector3(
  (1 - p.x) * 2 - 1,
  (1 - p.y) * 2 - 1,
  -p.z * 2
);

const bone = () => new THREE.Line(
  new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3()]),
  mat
);

const setBone = (b,a,c) => b.geometry.setFromPoints([a,c]);

/* ===================== CLONE FACTORY ===================== */
function createSkeleton(offset){
  const g = new THREE.Group();
  g.position.x = offset;
  scene.add(g);

  const b = {
    head:bone(), spine:bone(),
    lUA:bone(), lLA:bone(),
    rUA:bone(), rLA:bone(),
    lUL:bone(), lLL:bone(),
    rUL:bone(), rLL:bone()
  };

  Object.values(b).forEach(x=>g.add(x));
  return {group:g, bones:b};
}

const clones = [];
clones.push(createSkeleton(0));

/* ===================== PALM TIMER ===================== */
let palmTimer = 0;
const PALM_HOLD = 8000;

/* ===================== MEDIAPIPE POSE ===================== */
let latestPose = null;

const pose = new Pose({
  locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${f}`
});
pose.setOptions({
  modelComplexity: 0,          // ðŸ”¥ optimized
  smoothLandmarks: true,
  minDetectionConfidence: 0.6,
  minTrackingConfidence: 0.6
});
pose.onResults(r => latestPose = r.poseLandmarks);

/* ===================== MEDIAPIPE HANDS ===================== */
let handFrame = 0;

const hands = new Hands({
  locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`
});
hands.setOptions({
  maxNumHands: 2,
  modelComplexity: 0,
  minDetectionConfidence: 0.6,
  minTrackingConfidence: 0.6
});
hands.onResults(r=>{
  if(!r.multiHandLandmarks){ palmTimer = 0; return; }

  const palmUp = r.multiHandLandmarks.some(h=>{
    return h[8].y < h[0].y; // index above wrist
  });

  if(palmUp){
    palmTimer += 16;
    if(palmTimer > PALM_HOLD){
      palmTimer = 0;
      clones.push(createSkeleton(clones.length * 1.2));
    }
  } else palmTimer = 0;
});

/* ===================== APPLY SKELETON ===================== */
function updateSkeleton(lm){
  if(!lm) return;

  const head = vec(lm[0]);
  const LS = vec(lm[11]), RS = vec(lm[12]);
  const LW = vec(lm[15]), RW = vec(lm[16]);
  const LH = vec(lm[23]), RH = vec(lm[24]);
  const LA = vec(lm[27]), RA = vec(lm[28]);

  const shoulderMid = LS.clone().add(RS).multiplyScalar(0.5);
  const hipMid = LH.clone().add(RH).multiplyScalar(0.5);

  clones.forEach(c=>{
    c.group.position.lerp(shoulderMid, 0.25);

    setBone(c.bones.head, shoulderMid, head);
    setBone(c.bones.spine, shoulderMid, hipMid);

    setBone(c.bones.lUA, shoulderMid, LS);
    setBone(c.bones.lLA, LS, LW);
    setBone(c.bones.rUA, shoulderMid, RS);
    setBone(c.bones.rLA, RS, RW);

    setBone(c.bones.lUL, hipMid, LH);
    setBone(c.bones.lLL, LH, LA);
    setBone(c.bones.rUL, hipMid, RH);
    setBone(c.bones.rLL, RH, RA);
  });
}

/* ===================== CAMERA ===================== */
new Camera(video,{
  width: 960, height: 540,       // ðŸ”¥ lower resolution
  onFrame: async ()=>{
    await pose.send({image: video});

    handFrame++;
    if(handFrame % 3 === 0){
      await hands.send({image: video});
    }

    updateSkeleton(latestPose);
  }
}).start();

/* ===================== FPS-CAPPED RENDER LOOP ===================== */
let last = 0;
function animate(t){
  if(t - last > 33){ // ~30 FPS
    renderer.render(scene, camera3D);
    last = t;
  }
  requestAnimationFrame(animate);
}
animate();

/* ===================== RESIZE ===================== */
addEventListener("resize", ()=>{
  camera3D.aspect = innerWidth/innerHeight;
  camera3D.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
