<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Bone Architect â€“ FINAL WORKING</title>
<style>
  body { margin:0; overflow:hidden; background:#000 }
  video {
    position:fixed;
    inset:0;
    width:100vw;
    height:100vh;
    object-fit:cover;
    transform:scaleX(-1);
    z-index:-1;
  }
  canvas { position:fixed; inset:0 }
</style>
</head>

<body>

<video id="video" autoplay playsinline muted></video>
<canvas id="three"></canvas>

<!-- THREE -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>

<!-- MEDIAPIPE -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

<script>
/* ================= CAMERA SAFE START ================= */
const video = document.getElementById("video");

async function startCamera(){
  try{
    const stream = await navigator.mediaDevices.getUserMedia({
      video:{ width:960, height:540 },
      audio:false
    });
    video.srcObject = stream;
    await video.play();
    init(); // start system ONLY after camera works
  }catch(e){
    alert("Camera error: " + e);
  }
}

/* ================= THREE SCENE ================= */
let scene, cam3D, renderer;
let clones = [];

const mat = new THREE.LineBasicMaterial({ color:0x00f0ff });

const bone = ()=>new THREE.Line(
  new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(),new THREE.Vector3()]),
  mat
);

const vec = p => new THREE.Vector3(
  (1-p.x)*2-1,
  (1-p.y)*2-1,
  -p.z*2
);

const setBone = (b,a,c)=>b.geometry.setFromPoints([a,c]);

function createSkeleton(offset){
  const g = new THREE.Group();
  g.position.x = offset;
  scene.add(g);

  const b = {
    head:bone(), spine:bone(),
    lUA:bone(), lLA:bone(),
    rUA:bone(), rLA:bone(),
    lUL:bone(), lLL:bone(),
    rUL:bone(), rLL:bone()
  };
  Object.values(b).forEach(x=>g.add(x));
  return {group:g,bones:b};
}

/* ================= MEDIAPIPE ================= */
let latestPose = null;
let palmTimer = 0;
const PALM_HOLD = 8000;

const pose = new Pose({
  locateFile:f=>`https://cdn.jsdelivr.net/npm/@mediapipe/pose/${f}`
});
pose.setOptions({
  modelComplexity:0,
  smoothLandmarks:true,
  minDetectionConfidence:0.6,
  minTrackingConfidence:0.6
});
pose.onResults(r=>latestPose=r.poseLandmarks);

const hands = new Hands({
  locateFile:f=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`
});
hands.setOptions({
  maxNumHands:2,
  modelComplexity:0,
  minDetectionConfidence:0.6,
  minTrackingConfidence:0.6
});
hands.onResults(r=>{
  if(!r.multiHandLandmarks){ palmTimer=0; return; }

  const palmUp = r.multiHandLandmarks.some(h=>h[8].y < h[0].y);
  if(palmUp){
    palmTimer+=16;
    if(palmTimer>PALM_HOLD){
      palmTimer=0;
      clones.push(createSkeleton(clones.length*1.2));
    }
  }else palmTimer=0;
});

/* ================= INIT AFTER CAMERA ================= */
function init(){
  scene = new THREE.Scene();
  scene.background = new THREE.VideoTexture(video);

  cam3D = new THREE.PerspectiveCamera(45,innerWidth/innerHeight,0.1,100);
  cam3D.position.set(0,1.6,4);

  renderer = new THREE.WebGLRenderer({canvas:three,alpha:true});
  renderer.setSize(innerWidth,innerHeight);
  renderer.setPixelRatio(devicePixelRatio);

  clones.push(createSkeleton(0));

  run();
}

/* ================= APPLY SKELETON ================= */
function updateSkeleton(lm){
  if(!lm) return;

  const head = vec(lm[0]);
  const LS = vec(lm[11]), RS = vec(lm[12]);
  const LW = vec(lm[15]), RW = vec(lm[16]);
  const LH = vec(lm[23]), RH = vec(lm[24]);
  const LA = vec(lm[27]), RA = vec(lm[28]);

  const shoulderMid = LS.clone().add(RS).multiplyScalar(0.5);
  const hipMid = LH.clone().add(RH).multiplyScalar(0.5);

  clones.forEach(c=>{
    c.group.position.lerp(shoulderMid,0.25);

    setBone(c.bones.head, shoulderMid, head);
    setBone(c.bones.spine, shoulderMid, hipMid);

    setBone(c.bones.lUA, shoulderMid, LS);
    setBone(c.bones.lLA, LS, LW);
    setBone(c.bones.rUA, shoulderMid, RS);
    setBone(c.bones.rLA, RS, RW);

    setBone(c.bones.lUL, hipMid, LH);
    setBone(c.bones.lLL, LH, LA);
    setBone(c.bones.rUL, hipMid, RH);
    setBone(c.bones.rLL, RH, RA);
  });
}

/* ================= MAIN LOOP ================= */
let last=0, handFrame=0;

async function run(t){
  if(t-last>33){ // ~30fps
    await pose.send({image:video});
    handFrame++;
    if(handFrame%3===0) await hands.send({image:video});
    updateSkeleton(latestPose);
    renderer.render(scene,cam3D);
    last=t;
  }
  requestAnimationFrame(run);
}

/* ================= START ================= */
startCamera();

addEventListener("resize",()=>{
  cam3D.aspect=innerWidth/innerHeight;
  cam3D.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
